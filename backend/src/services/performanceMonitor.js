// ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ ÏÑúÎπÑÏä§
const { getRedisClient } = require('../config/redis');
const os = require('os');

class PerformanceMonitor {
  constructor() {
    this.metrics = {
      requests: new Map(),
      dbQueries: new Map(),
      cacheHits: 0,
      cacheMisses: 0,
      vectorOperations: new Map(),
      memoryUsage: [],
      cpuUsage: []
    };

    this.thresholds = {
      apiLatency: 200,      // ms
      dbQueryTime: 100,     // ms
      vectorOperation: 50,  // ms
      memoryUsage: 80,      // %
      cpuUsage: 70         // %
    };

    // Ï£ºÍ∏∞Ï†Å Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
    this.startMonitoring();
  }

  // API ÏöîÏ≤≠ Ï∂îÏ†Å
  trackRequest(endpoint, startTime) {
    const duration = Date.now() - startTime;

    if (!this.metrics.requests.has(endpoint)) {
      this.metrics.requests.set(endpoint, {
        count: 0,
        totalTime: 0,
        avgTime: 0,
        maxTime: 0,
        p95: [],
        p99: []
      });
    }

    const stats = this.metrics.requests.get(endpoint);
    stats.count++;
    stats.totalTime += duration;
    stats.avgTime = stats.totalTime / stats.count;
    stats.maxTime = Math.max(stats.maxTime, duration);

    // Percentile Í≥ÑÏÇ∞ÏùÑ ÏúÑÌïú ÏÉòÌîå Ï†ÄÏû• (ÏµúÍ∑º 1000Í∞ú)
    stats.p95.push(duration);
    stats.p99.push(duration);
    if (stats.p95.length > 1000) {
      stats.p95.shift();
      stats.p99.shift();
    }

    // ÏûÑÍ≥ÑÍ∞í Ï¥àÍ≥º Ïãú Í≤ΩÍ≥†
    if (duration > this.thresholds.apiLatency) {
      console.warn(`‚ö†Ô∏è API ÏßÄÏó∞: ${endpoint} - ${duration}ms`);
      this.sendAlert('api_latency', { endpoint, duration });
    }

    return duration;
  }

  // DB ÏøºÎ¶¨ Ï∂îÏ†Å
  trackQuery(queryType, startTime, queryInfo = {}) {
    const duration = Date.now() - startTime;

    if (!this.metrics.dbQueries.has(queryType)) {
      this.metrics.dbQueries.set(queryType, {
        count: 0,
        totalTime: 0,
        avgTime: 0,
        maxTime: 0,
        slowQueries: []
      });
    }

    const stats = this.metrics.dbQueries.get(queryType);
    stats.count++;
    stats.totalTime += duration;
    stats.avgTime = stats.totalTime / stats.count;
    stats.maxTime = Math.max(stats.maxTime, duration);

    // ÎäêÎ¶∞ ÏøºÎ¶¨ Í∏∞Î°ù
    if (duration > this.thresholds.dbQueryTime) {
      stats.slowQueries.push({
        duration,
        timestamp: new Date(),
        ...queryInfo
      });

      // ÏµúÍ∑º 100Í∞úÎßå Ïú†ÏßÄ
      if (stats.slowQueries.length > 100) {
        stats.slowQueries.shift();
      }

      console.warn(`üêå ÎäêÎ¶∞ ÏøºÎ¶¨: ${queryType} - ${duration}ms`);
    }

    return duration;
  }

  // Î≤°ÌÑ∞ Ïó∞ÏÇ∞ Ï∂îÏ†Å
  trackVectorOperation(operationType, vectorSize, startTime) {
    const duration = Date.now() - startTime;
    const key = `${operationType}_${vectorSize}`;

    if (!this.metrics.vectorOperations.has(key)) {
      this.metrics.vectorOperations.set(key, {
        count: 0,
        totalTime: 0,
        avgTime: 0,
        maxTime: 0
      });
    }

    const stats = this.metrics.vectorOperations.get(key);
    stats.count++;
    stats.totalTime += duration;
    stats.avgTime = stats.totalTime / stats.count;
    stats.maxTime = Math.max(stats.maxTime, duration);

    if (duration > this.thresholds.vectorOperation) {
      console.warn(`üî¢ ÎäêÎ¶∞ Î≤°ÌÑ∞ Ïó∞ÏÇ∞: ${operationType} (${vectorSize}Ï∞®Ïõê) - ${duration}ms`);
    }

    return duration;
  }

  // Ï∫êÏãú ÌûàÌä∏/ÎØ∏Ïä§ Ï∂îÏ†Å
  trackCacheHit() {
    this.metrics.cacheHits++;
  }

  trackCacheMiss() {
    this.metrics.cacheMisses++;
  }

  // ÏãúÏä§ÌÖú Î¶¨ÏÜåÏä§ Î™®ÎãàÌÑ∞ÎßÅ
  async monitorSystemResources() {
    // CPU ÏÇ¨Ïö©Î•†
    const cpus = os.cpus();
    let totalIdle = 0;
    let totalTick = 0;

    cpus.forEach(cpu => {
      for (const type in cpu.times) {
        totalTick += cpu.times[type];
      }
      totalIdle += cpu.times.idle;
    });

    const cpuUsage = 100 - ~~(100 * totalIdle / totalTick);
    this.metrics.cpuUsage.push({
      timestamp: new Date(),
      usage: cpuUsage
    });

    // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Î•†
    const totalMem = os.totalmem();
    const freeMem = os.freemem();
    const memUsage = ((totalMem - freeMem) / totalMem) * 100;

    this.metrics.memoryUsage.push({
      timestamp: new Date(),
      usage: memUsage,
      total: totalMem,
      free: freeMem
    });

    // ÏµúÍ∑º 60Í∞ú Îç∞Ïù¥ÌÑ∞Îßå Ïú†ÏßÄ (1ÏãúÍ∞Ñ)
    if (this.metrics.cpuUsage.length > 60) {
      this.metrics.cpuUsage.shift();
    }
    if (this.metrics.memoryUsage.length > 60) {
      this.metrics.memoryUsage.shift();
    }

    // ÏûÑÍ≥ÑÍ∞í ÌôïÏù∏
    if (cpuUsage > this.thresholds.cpuUsage) {
      console.warn(`üî• ÎÜíÏùÄ CPU ÏÇ¨Ïö©Î•†: ${cpuUsage}%`);
      this.sendAlert('high_cpu', { usage: cpuUsage });
    }

    if (memUsage > this.thresholds.memoryUsage) {
      console.warn(`üíæ ÎÜíÏùÄ Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Î•†: ${memUsage.toFixed(2)}%`);
      this.sendAlert('high_memory', { usage: memUsage });
    }
  }

  // ÏÑ±Îä• Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
  generateReport() {
    const cacheHitRate = this.metrics.cacheHits /
      (this.metrics.cacheHits + this.metrics.cacheMisses) || 0;

    // API ÏóîÎìúÌè¨Ïù∏Ìä∏Î≥Ñ ÌÜµÍ≥Ñ
    const apiStats = {};
    this.metrics.requests.forEach((stats, endpoint) => {
      const sorted = [...stats.p95].sort((a, b) => a - b);
      apiStats[endpoint] = {
        count: stats.count,
        avgTime: Math.round(stats.avgTime),
        maxTime: stats.maxTime,
        p95: sorted[Math.floor(sorted.length * 0.95)] || 0,
        p99: sorted[Math.floor(sorted.length * 0.99)] || 0
      };
    });

    // DB ÏøºÎ¶¨ ÌÜµÍ≥Ñ
    const dbStats = {};
    this.metrics.dbQueries.forEach((stats, queryType) => {
      dbStats[queryType] = {
        count: stats.count,
        avgTime: Math.round(stats.avgTime),
        maxTime: stats.maxTime,
        slowCount: stats.slowQueries.length
      };
    });

    // Î≤°ÌÑ∞ Ïó∞ÏÇ∞ ÌÜµÍ≥Ñ
    const vectorStats = {};
    this.metrics.vectorOperations.forEach((stats, operation) => {
      vectorStats[operation] = {
        count: stats.count,
        avgTime: Math.round(stats.avgTime),
        maxTime: stats.maxTime
      };
    });

    // ÏãúÏä§ÌÖú Î¶¨ÏÜåÏä§ ÌèâÍ∑†
    const avgCpu = this.metrics.cpuUsage.reduce((sum, item) =>
      sum + item.usage, 0) / this.metrics.cpuUsage.length || 0;
    const avgMem = this.metrics.memoryUsage.reduce((sum, item) =>
      sum + item.usage, 0) / this.metrics.memoryUsage.length || 0;

    return {
      timestamp: new Date(),
      summary: {
        cacheHitRate: `${(cacheHitRate * 100).toFixed(2)}%`,
        totalRequests: Array.from(this.metrics.requests.values())
          .reduce((sum, stats) => sum + stats.count, 0),
        totalDbQueries: Array.from(this.metrics.dbQueries.values())
          .reduce((sum, stats) => sum + stats.count, 0),
        avgCpuUsage: `${avgCpu.toFixed(2)}%`,
        avgMemoryUsage: `${avgMem.toFixed(2)}%`
      },
      apiEndpoints: apiStats,
      dbQueries: dbStats,
      vectorOperations: vectorStats,
      systemResources: {
        cpu: {
          current: this.metrics.cpuUsage[this.metrics.cpuUsage.length - 1]?.usage || 0,
          average: avgCpu.toFixed(2)
        },
        memory: {
          current: this.metrics.memoryUsage[this.metrics.memoryUsage.length - 1]?.usage || 0,
          average: avgMem.toFixed(2)
        }
      }
    };
  }

  // RedisÏóê Î©îÌä∏Î¶≠ Ï†ÄÏû•
  async saveMetrics() {
    const redis = getRedisClient();
    if (!redis) return;

    try {
      const report = this.generateReport();
      const key = `performance:metrics:${Date.now()}`;

      await redis.setex(key, 86400, JSON.stringify(report)); // 24ÏãúÍ∞Ñ Î≥¥Í¥Ä

      // ÏµúÍ∑º Î©îÌä∏Î¶≠ Î¶¨Ïä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
      await redis.lpush('performance:metrics:list', key);
      await redis.ltrim('performance:metrics:list', 0, 1439); // ÏµúÍ∑º 1440Í∞ú (24ÏãúÍ∞Ñ)
    } catch (error) {
      console.error('Î©îÌä∏Î¶≠ Ï†ÄÏû• Ïã§Ìå®:', error);
    }
  }

  // ÏïåÎ¶º Ï†ÑÏÜ°
  async sendAlert(type, data) {
    // Ïã§Ï†ú ÌôòÍ≤ΩÏóêÏÑúÎäî Slack, Email Îì±ÏúºÎ°ú ÏïåÎ¶º Ï†ÑÏÜ°
    console.error(`üö® ÏÑ±Îä• Í≤ΩÍ≥† [${type}]:`, data);

    const redis = getRedisClient();
    if (redis) {
      await redis.lpush('performance:alerts', JSON.stringify({
        type,
        data,
        timestamp: new Date()
      }));
      await redis.ltrim('performance:alerts', 0, 99); // ÏµúÍ∑º 100Í∞ú
    }
  }

  // Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
  startMonitoring() {
    // 1Î∂ÑÎßàÎã§ ÏãúÏä§ÌÖú Î¶¨ÏÜåÏä§ Ï≤¥ÌÅ¨
    setInterval(() => {
      this.monitorSystemResources();
    }, 60000);

    // 5Î∂ÑÎßàÎã§ Î©îÌä∏Î¶≠ Ï†ÄÏû•
    setInterval(() => {
      this.saveMetrics();
    }, 300000);

    // 10Î∂ÑÎßàÎã§ Î¶¨Ìè¨Ìä∏ Ï∂úÎ†•
    setInterval(() => {
      const report = this.generateReport();
      console.log('üìä ÏÑ±Îä• Î¶¨Ìè¨Ìä∏:', JSON.stringify(report, null, 2));
    }, 600000);
  }

  // Ïã§ÏãúÍ∞Ñ ÎåÄÏãúÎ≥¥Îìú Îç∞Ïù¥ÌÑ∞
  async getDashboardData() {
    const report = this.generateReport();
    const redis = getRedisClient();

    if (redis) {
      // ÏµúÍ∑º ÏïåÎ¶º Í∞ÄÏ†∏Ïò§Í∏∞
      const alerts = await redis.lrange('performance:alerts', 0, 9);
      report.recentAlerts = alerts.map(a => JSON.parse(a));
    }

    return report;
  }

  // ÌäπÏ†ï ÏóîÎìúÌè¨Ïù∏Ìä∏ ÏÉÅÏÑ∏ Î∂ÑÏÑù
  analyzeEndpoint(endpoint) {
    const stats = this.metrics.requests.get(endpoint);
    if (!stats) return null;

    const sorted = [...stats.p95].sort((a, b) => a - b);

    return {
      endpoint,
      totalCalls: stats.count,
      performance: {
        avg: Math.round(stats.avgTime),
        min: sorted[0] || 0,
        max: stats.maxTime,
        p50: sorted[Math.floor(sorted.length * 0.5)] || 0,
        p75: sorted[Math.floor(sorted.length * 0.75)] || 0,
        p90: sorted[Math.floor(sorted.length * 0.9)] || 0,
        p95: sorted[Math.floor(sorted.length * 0.95)] || 0,
        p99: sorted[Math.floor(sorted.length * 0.99)] || 0
      },
      distribution: this.calculateDistribution(sorted)
    };
  }

  // ÏùëÎãµ ÏãúÍ∞Ñ Î∂ÑÌè¨ Í≥ÑÏÇ∞
  calculateDistribution(times) {
    const buckets = [0, 50, 100, 200, 500, 1000, 2000, 5000];
    const distribution = {};

    buckets.forEach((bucket, i) => {
      const nextBucket = buckets[i + 1] || Infinity;
      const count = times.filter(t => t >= bucket && t < nextBucket).length;
      distribution[`${bucket}-${nextBucket === Infinity ? '+' : nextBucket}ms`] = count;
    });

    return distribution;
  }
}

// Ïã±Í∏ÄÌÜ§ Ïù∏Ïä§ÌÑ¥Ïä§
let instance = null;

module.exports = {
  getPerformanceMonitor: () => {
    if (!instance) {
      instance = new PerformanceMonitor();
    }
    return instance;
  },

  // ÎØ∏Îì§Ïõ®Ïñ¥Î°ú ÏÇ¨Ïö©
  performanceMiddleware: (req, res, next) => {
    const monitor = module.exports.getPerformanceMonitor();
    const startTime = Date.now();

    // ÏùëÎãµ ÏôÑÎ£å Ïãú Ï∂îÏ†Å
    res.on('finish', () => {
      monitor.trackRequest(req.path, startTime);
    });

    next();
  }
};
